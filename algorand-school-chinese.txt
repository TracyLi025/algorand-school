Algorand School
#Algorand 学校

2022


Cosimo Bassi
Solutions Architect at Algorand Inc.

cosimo.bassi@algorand.com


Open Source: github.com/cusma/algorand-school

Our journey today:
#我们今天的旅程：

understanding Algorand Consensus and Algorand Networks, how to use Algorand Dev Tools, how to develop decentralized applications on the Algorand Virtual Machine
#了解Algorand共识和Algorand网络，如何使用Algorand开发工具，如何开发去中心化应用以及Algorand虚拟机

Agenda
#日程

Blockchain as an infrastructure
Analog properties for Digital things
Algorand Consensus
#Algorand共识
Algorand Sustainability
Algorand Decentralized Governance
#Algorand去中心化治理
Algorand Networks
#Algorand网络
Algorand Interoperability
Algorand Transactions
#Algorand交易
Algorand Accounts
#Algorand账户
Algorand Virtual Machine
#Algorand虚拟机
Algorand Smart Contracts on Layer-1
#Algorand在Layer-1的智能合约
Smart Signatures & Smart Contracts
#智能签名与智能合约
TEAL
PyTEAL
dApp Example & Use Cases
#dApp试例与使用案例

4
BLOCKCHAIN AS INFRASTRUCTUREFor native digital value

Blockchain is a digital infrastructure for value
5
"The ability to create something which is not duplicable in the digital world has enormous value."

Eric Schmidt


The infrastructure trilemma
6
TRILEMMA
2
3
1
SECURITY (INT/EXT)
ACCESSIBILITY
EFFICIENCY
Public or private? Who has the control? Duty and responsibility? Aligned incentives?


The problem of native digital value
7
In the digital age
everything can be represented in bits 
as a string of 0 and 1
Strings of 0 and 1 are useful
because you can
duplicate them easily
Value is therefore difficult to represent in the digital age:
SCARCITY, AUTHENTICITY, UNICITY


How to build such infrastructure? Protocol is the answer
8
Just like TCP/IP is the foundational protocol for the modern Internet infrastructure, we will solve the problem through an protocol.

This is not just an information technology problem
9
DISTRIBUTED SYSTEMS
CRYPTOGRAPHY
GAME THEORY
PUBLIC
TAMPER-PROOF
TRANSPARENT
TRUSTLESS
LEDGER
Distributed systems and cryptography are elements of the communication infrastructure. We need a third element: game theory.

Who controls the system? Nobody… everybody!
10
PAST
FUTURE
DISTRIBUTED SYSTEMS
No absolute power, no single point of failure.


Don’t trust, verify!
11
Nobody can break the rules…
and
…everybody can verify.
CRYPTOGRAPHY


Align incentives: collective self-protecting system
12
GAME THEORY
Equilibrium in which attacking the system is less convenient than protecting it.

Cost of the attack: make malicious behaviours expensive.


13
ANALOG PROPERTIES
FOR DIGITAL THINGS
Consensus as “law of Physics” for digital world

Who owns what? Let’s write it down!
14
A blockchain is a public ledger of transactional data.
World's first writing — cuneiform — traces its beginnings back to an ancient system of accounting.
WHO

OWNS

WHAT
Writing systems: from prehistory to history of humankind.

More copies are better than one!
15
Distributed and replicated across a system of multiple nodes in a network.
All “ledger keepers” should work together, using the same set rules, to verify the transactions to add to each copy of the finalized ledger. 


16
Atoms can’t be copy & pasted and are obliged to follow the arrow of time!
Bits can be copy & pasted and are not obliged to follow the arrow of time!
Entropy, irreversibility and the arrow of time
In a distributed system is hard to ensure that the information follows a consequential time. Also, the arrow of time could bypassed reverting transactions. The ledger of information must respect a precise history and must not allow arbitrary creation, duplication or deletion of information. 

A chain of transactions organized in blocks
17
The “block” refers to a set of transactions that are proposed and verified by the other nodes and eventually added to the ledger (no copy & paste).
The “chain” refers to the fact that each block of transactions contains proof (a cryptographic hash) of what was in the previous block (arrow of time).





Can transactions be reverted or modified ex-post? No! Dura lex, sed lex!


A distributed state machine
18
A machine
The evolution of the states of the system is determined…

SYSTEM STATE
S0

SYSTEM STATE
Sn

SYSTEM STATE
S1
BLOCK N
SMART CONTRACT
TRANSACTION
The evolution of the states of the system is determined…
…acting on atoms, through the inviolable laws of Physics!
…acting on bits, through what?
BLOCK 1
SMART CONTRACT
TRANSACTION
The more complex the state transition the more power I consume: adding 1 transaction per month is easy, executing thousands of smart contracts on the AVM is complicated.

The responsibility of correct information
19
Margaret Hamilton in 1969, standing next to listings of the software she and her MIT team produced for the Apollo project.
BLOCK PROPOSER
GENESIS BLOCK
BLOCK 1
BLOCK N
BLOCK N+1
How should we replace the role played by the law of Physics in evolving the state of a machine?

With a set of software rules, called Consensus Protocol that evolves the state of the system. 
Paleo-computing: no IDE, no syntax highlighting, handwritten code (value of conciseness).

The architecture of consensus
20
Temple of Concordia
#康考迪亚神庙（协和神殿）
Valley of Temples (Agrigento), 440-430 B.C.
#神庙谷（阿格里真托），公元前440-430年
How to choose the proposer for the next block for a public and permissionless blockchain?
#如何为一个公开且无需许可的区块链选择下一个区块的提出者？

How to ensure that there is no ambiguity in the choice of the next block?
#如何保证下一个区块的选择是没有歧义的？

How to ensure that the blockchain stays unique and has no forks?
#如何确保区块链是独特且无分叉的？

How to ensure that consensus mechanism itself can evolve over time while the blockchain is an immutable ledger?
#当区块链是一个不可变的账本时，如何确保共识机制本身是可随时间进化的？

It is the largest and best-preserved Doric temple in Sicily[5] and one of the best-preserved Greek temples in general,[1] especially of the Doric order. Named after Concordia.
In ancient Roman religion, Concordia is the goddess who embodies agreement in society. Her Greek equivalent is usually regarded as Harmonia, with musical harmony a metaphor for an ideal of social concord.
This tells us a lot about the value of such a civilization!

Proof of Work consensus mechanism
21
Miners compete with each other to append the next block and earn a reward for the effort, fighting to win an expensive computational battle.
#矿工们相互竞争以生成新的区块并赢取奖励，争取赢得一场昂贵的计算战争。
The more computational power, the higher the probability of being elected as block proposer.
PoW


Proof of Work limits
22
Huge electrical consumption
#巨大耗电量
Concentration of governance in few mining farms
#治理权集中在少数矿池
Soft-forking of the blockchain
#区块链的软分叉


Proof of Stake consensus mechanism
23
Network participants show their commitment and interest in keeping the ledger safe and secure proving the ownership of value stored on the ledger itself.

The higher the skin in the game the higher the probability of being elected as block proposer.


Proof of Stake limits
24
CRITICAL ISSUES
BONDED PROOF OF STAKE
#担保权益证明
Validators bind their stake, to show their commitment in validating and appending a new block. Misbehaviors are punished.
#验证者质押他们的资金，以展现他们在验证和创建新区块时的承诺。行为不端者将受到惩罚。
Participating in the consensus protocol makes users’ stakes illiquid
#参与共识协议让用户的资产缺少流动性
Risk of economic barrier to entry
#经济进入壁垒的风险
DELEGATED PROOF OF STAKE
#委托权益证明
Users delegate the validation of new blocks to a fixed committee, through weighted voting based on their stakes.
#用户通过基于他们质押资金的加权投票将新区块的验证委托给一个固定的委员会。
Known delegate nodes, therefore exposed to DDoS attacks
#代表节点已知，因此很容易遭受DDoS攻击
Centralization of governance
#中心化治理
BPoS
DPoS
It’s like playing Battleship knowing the coordinates of adversary in advance.

25
ALGORAND CONSENSUSPure Proof of Stake (PPoS)

Is the Blockchain Trilemma unsolvable?
#区块链的三难困境是无法解决的吗？
26
TRILEMMA
#三难困境
2
3
1
SECURITY
#安全性
SCALABILITY
#可扩展性
DECENTRALIZATION
#去中心化


Scalable		billions of users
#可扩展		数十亿用户
Efficient		1000 TPS (10x work in progress)
#高效		1000 TPS (10x 升级工作正在进行中)
Fast			< 5s per block
#快速		< 5秒 每区块
Low fees		0.001 ALGO per txn
#低手续费		0.001 ALGO 每笔交易
No Soft Forks 	prob. < 10-18
#无软分叉 		概率 < 10-18
Instant Transaction Finality
#即时交易终结性
Minimal hardware node requirements
#最小化节点的硬件需求
No delegation or binding of the stake
#无需代理和质押资金
No minimum stake
#无最低质押资金
Carbon negative
#碳中和
Secure with respect DDoS
#DDoS安全
Network Partitioning resilience
#网络分片的恢复力
Algorand PPoS Consensus
#Algorand PPoS 共识
27
Silvio Micali  Algorand Founder
Professor MIT, Turing Award, Gödel Prize
#MIT教授，图灵奖获得者，哥德尔奖获得者
Digital Signatures, Probabilistic Encryption, Zero-Knowledge Proofs,
#数字签名，概率加密，零知识证明，
Verifiable Random Functions and other primitives of modern cryptography.
#可验证随机函数和其他现代密码学基本原语。

Flat fee is very powerful for business models: given a users base, an estimation of users activity (tx/day) a business team can foresee the costs and hedge the on-chain resources.

Tamper-proof, unique and verifiable dices
28





VRF
Dices are perfectly balanced and equiprobable, nobody could tamper their result!
Keep observing dice rolls by no means increases the chance of guessing the next result!
Each dice is uniquely signed by its owner, nobody can roll someone else dices!
Dices are publicly verifiable, everybody can read the results of a roll!


Who chose the next block?
#谁选择下一个区块？
29
VRF
VRF
VRF
VRF
WIN!
Each ALGO could be assimilated to a tamper-proof dice participating in a safe and secret cryptographic dice roll. More ALGOs more dices to roll.

For each new block, dice rolls are performed in a distributed, parallel and secret and manner, directly on online accounts’ hardware (in microseconds).

The winner is revealed in a safe and verifiable way only after winning the dice roll, proposing the next block.


A glimpse on “simplified” VRF sortition
#对“简化版”VRF抽签的浅析
30
A secret key (SK) / public verification key (VK) pair is associated with each ALGO in the account
#账户中的每一个ALGO都关联着一个私钥(SK)/公钥(VK)对
For each new round r of the consensus protocol a threshold L(r) is defined
#对共识协议中每新一轮r都定义一个阈值L(r)
Each ALGO in the account performs a VRF, using its own secret key (SK), to generate:
#账户中的每一个ALGO使用其自带的密钥(SK)进行一次VRF，来生成：
a pseudo-random number:		Y = VRFSK(seed)
#一个伪随机数:		Y = VRFSK(seed)
the verifiable associated proof:	⍴SK(seed)
#可验证的相关证明:	⍴SK(seed)
If Y = VRFSK(seed) < L(r), that specific ALGO “wins the lottery” and viraly propagates the proof of its victory ⍴SK(seed) to other network’s nodes, through “gossiping” mechanism
#如果Y = VRFSK(seed) < L(r)，则该特定的ALGO“中奖“并将其获胜的证据⍴SK(seed)通过八卦协议病毒式传播到其他网络节点
Others node can use the public verification key (VK) to verify, through ⍴SK(seed), that the number Y was generated by that specific ALGO, owned by the winner of the lottery
#其他节点可以使用公钥(VK)通过⍴SK(seed)来验证Y是由中奖者所持有的特定ALGO生成的

Pure Proof of Stake, in short
#总而言之，纯粹权益证明
31
Through the cryptographic lottery, an online account is elected with probability directly proportional to its stake: each ALGO corresponds to an attempt to win the lottery!
#通过密码学抽奖，一个在线用户被选中的概率与他持有的份额成正比：每个ALGO都对应着一次抽奖机会！




An account is elected to propose the next block
#一个账户被选中以提议下一个区块
A committee is elected to filter and vote on the block proposals
#一个委员会被选出对这些区块提案进行筛选和投票
A new committee is elected to reach a quorum and certify the block
#一个新的委员会被选出以达到规定人数并认证该区块
The new block is appended to the blockchain
#新的区块被添加到区块链上
Each round of the consensus protocol appends a new block in the blockchain:
#每一轮共识协议都会添加一个新的区块到区块链上：


Pure Proof of Stake security
#纯粹权益证明的安全性
32
Algorand’s decentralized Byzantine consensus protocol can tolerate an arbitrary number of malicious users as long as honest users hold a super majority of the total stake in the system.
#Algorand的去中心化拜占庭协议可以容忍任意数量的恶意用户，只要诚实用户持有系统中绝对多数的总权益。
The adversary does not know which users he should corrupt.
#对手并不知道该破坏哪些用户。
The adversary realizes which users are selected too late to benefit from attacking them.
#对手了解哪些用户被选择的时候为时已晚，无法从破坏他们中获益。
Each new set of users will be privately and individually elected.
#每一组新用户都是秘密且独立被选出的。
During a network partition in Algorand, the adversary is never able to convince two honest users to accept two different blocks for the same round.
#在Algorand每一次网络分区中，对手永远无法说服两名诚实用户在同一轮接受两个不同的区块。
Algorand is able to recover shortly after network partition is resolved and guarantees that new blocks will be generated at the same speed as before the partition.
#Algorand能够在解决网络分区后很快恢复，并保证以与分区之前相同的速度生成新的区块。


Pure Proof of Stake: the output!
33
BLOCKS
> 20M with 0 downtime
BLOCKCHAIN SIZE
~ 1 TB
ADDRESSES
> 23M with ~ 2M monthly active addresses
AVG. BLOCK FINALIZATION
~ 4,4 sec per block
TXNS WEEKLY VOLUME
~ 11M transactions (March 2022)
TPS WEEKLY PEAK
~ 1150 transactions per second
* up to March 2022
This is the output that such a complex machine has produced so far… We still have to answer to the opening question: “is this machine good at consuming input resources to produce the desired output for which it has been designed for?”

Algorand Layer-1 primitives
#Algorand Layer-1 原语
34

Algorand Standard Assets (ASA)
#Algorand 标准资产

Atomic Transfers
#原子交易
(AT)

Algorand Virtual Machine (AVM)





Algorand State Proof (ASP)




TRUSTLESS
INTEROPERABLE
POST-QUANTUM SECURE





What does execution on Layer-1 mean?
35
B1
B2
...
Br
ASC1 CALL
ASC1 CALL
ASC1 CALL
TXN 1
ASC1 CALL
L-1 CONSENSUS COMMITTEE

4.5 sec
L-1 CONSENSUS COMMITTEE

4.5 sec
L-1 CONSENSUS COMMITTEE

4.5 sec
EXECUTION ON PPoS CONSENSUS LEVEL
up to 5000 txn/block
up to 5000 txn/block
AVM execution does not slow down the whole blocks production!
up to 5000 txn/block
up to 5000 txn/block
Each complex system is characterised by a “natural pulsation”. For electrical networks is the grid’s frequency, for automated assembly lines is the production tack-time. We, humans, are complex systems, our natural pulsations is the heartbeat. Block time is Algorand’s heartbeat!

What does execution on Layer-1 mean?
36
Smart Contracts are executed “at consensus level”
Benefit from network's speed, security, and scalability
Fast trustless execution (~4.5 seconds per block)
Low cost execution (0.001 ALGO regardless SC’s complexity)
Instant Finality of Smart Contracts’ effects
Native interoperability with Layer-1 primitives
Safe high level languages (PyTeal, Reach, Clarity)
Low energy consumption


37
ALGORAND SUSTAINABILITY“Permission-less” is not “Responsibility-less”

Proof of unsustainable Work
38
Proof of Work is a planetary wasteful computational battle, in which miners MUST burn energy to secure the blockchain.
Showing off personal commitment in the ecosystem through the consumption of computational and energetic resources is at the core of PoW consensus mechanism.

Our planet Earth can no longer afford unsustainable technologies.


39
A matter of orders of magnitude (PoW vs PPoS)
Eiffel Tower
Paper sheet thickness
2x Burj Khalifa
103
102
10-5


40
You like to win easy!
What about others Proof of Stake?


When the going gets tough, the tough get going (PoS vs PPoS)
41
Blockchain sustainability must consider scalable end-user transactions (uTPS) finality (f), nodes hardware (N), and secure network decentralization (d).





Being sustainable while centralized, insecure or not scalable
is worthless!
DECENTRALIZED
SECURE
NETWORK
(running on Consensus Protocol)

(f, N, d)
INPUT
OUTPUT
POWER
(Pval)
END-USER
FINALIZED
TRANSACTIONS
(uTPS)


Reframing the question
42
Is Algorand blockchain efficient
at consuming energy 
to finalize end user useful transactions
in a secure, scalable and decentralized way?


Algorand solves blockchain trilemma sustainably
43
Algorand transactions are 100% available to end-users
(other PoS blockchains consume their own transactions for consensus)
Algorand transactions are 100% instantly final
(other PoS must consume the energy of several blocks to ensure transactions’ finality)
Algorand transactions are secured by a very decentralized network
(some PoS blockchain have only few validators)
Algorand security is a feature of its own efficiency
(Algorand never experienced downtime since the genesis block)


44
DECENTRALIZED GOVERNANCEGoverning ALGO
#去中心化治理

ALGO Decentralized Governance
#ALGO去中心化治理
45
Decentralized Governors
#去中心化治理者
Vote on-chain, each quarter, by staking their ALGO-votes in governance.
#每季度通过投入他们所持有的ALGO进行链上投票
Decide how the AERP should be utilised and distributed, to support the long term development of the Algorand network.
#决定AERP的使用和分发，以支持Algorand网络的长期发展。
Are rewarded for their efforts, based on their stake in governance.
#基于他们参与治理的份额，对他们的付出进行奖励
Decentralized Governance over Algorand Ecosystem Resource Pool (AERP), including Ecosystem Support, Participation Incentives and Contingent Rewards (total of 3,2B ALGOs) previously entrusted to the Algorand Foundation.
#对Algorand 生态资源池(AERP)进行去中心化治理，包括了生态系统支持、参与奖励，以及或有奖励（总额达32亿ALGO），此前由Algorand基金会受托。


The ALGO
46
* January 2022
#*2022年一月
GENESIS BLOCK
#创世区块
Main Net, June 2019
#主网，2019年6月
GENESIS HASH
#创世哈希
wGHE2Pwdvd7S12BL5FaOP20EGYesN73ktiC1qzkkit8=
TOTAL SUPPLY (fixed)
#总供应量（固定）
10 B ALGO
#100亿ALGO
MINIMAL UNIT
#最小分割单位
1 microALGO = 10-6 ALGO
#1 微Algo = 10-6 ALGO
CIRCULATING SUPPLY
#流动供应量
~ 6,5 B ALGO
#～ 65亿ALGO
PPoS PARTICIPATING STAKE
#PPoS参与份额
~ 2,1 B ALGO
#～ 21亿ALGO
GOVERNANCE STAKE
#治理份额
~ 3,2 B ALGO
#32亿ALGO
GOVERNORS
#治理者
~ 65 k
#～ 六万五千人

47
ALGORAND NETWORKSNodes, Indexer and APIs
#ALGORAND网络节点，索引器和API

Algorand Node configurations
#Algorand节点配置
48
Non-Relay Nodes
#非中继节点
Participate in the PPoS consensus (if hosting participation keys)
#参与PPoS共识（如果持有参与密钥）
Connect only to Relay Nodes 
#只和中继节点连接
Light Configuration: store just the lastest 1000 blocks (Fast Catch-Up)
#轻量化配置：只存储最新的1000个区块（快速更新）
Archival Configuration: store all the chain since the genesis block
#存档配置：存储从创世区块开始的所有链

Relay Nodes
#中继节点
Communication routing to a set of connected Non-Relay Nodes
#到一组连接的非中继节点的通信路由
Connect both with Non-Relay Nodes and Relay Nodes
#连接中继节点和非中继节点
Route blocks to all connected Non-Relay Nodes
#将区块路由至所有连接的非中继节点
Highly efficient communication paths, reducing communication hops
#高效通信路径，减少通信时的跃点数


Example of Algorand Network topology
#节点网络拓扑案例
49
Node Metrics
#节点指标
Non-Relay Nodes: 	> 1600
#非中继节点: 	> 1600
Relay Nodes:		> 120
#中继节点:		 > 120


50
Access to Algorand Network
#访问Algorand网络
The Algorand blockchain is a distributed system of nodes each maintaining their local state based on validating the history of blocks and the transactions therein. Blockchain state integrity is maintained by the consensus protocol which is implemented within the Algod daemon (often referred to as the node software).
#Algorand区块链是一个由节点组成的分布式系统，每个节点通过验证块的历史和其中的交易来维护它们的本地状态。区块链状态的完整性由在守护程序Algod(通常指的是节点软件)中实现的共识协议来维护。

An application connects to the Algorand blockchain through an Algod client, requiring:
#一个应用通过Algod客户端连接到Algorand区块链需要：

a valid Algod REST API endpoint IP address
#一个有效的algod REST API 端点IP地址
an Algod token from an Algorand node connected to the network you plan to interact with
#一个从连接欲交互网络的Algorand节点获得的algod令牌

These two pieces of information can be provided by your local node or by a third party node aaS.
#这两部分信息可以由本地节点或者一个第三方节点作为服务提供。


51
How to get an Algod Client?
#如何获得一个Algod客户端？
There are three ways to get a REST API Algod endpoint IP address / access token, each with their respective pros and cons depending on development goals.
#有三种方法可以获得REST API Algod 端点IP地址/访问令牌，每种方法根据开发目标都有各自的优缺点。


52
Algorand Networks
#Algorand网络


53
Algorand Node -  Writing on the blockchain
#Algorand节点 - 写在区块链上
Install (Linux, MacOS, Windows)
#安装（Linux, MacOS, Windows）
Choose a network (MainNet, TestNet, BetaNet, PrivateNet)
#选择一个网络（MainNet, TestNet, BetaNet, PrivateNet）
Start & Sync with the network, Fast Catchup
#开始&同步网络，快速跟进

genesis.json (mainnet)

{
  "alloc": [
    {
      "addr": "7377777777777777...77777777UFEJ2CI",
      "comment": "RewardsPool",
      "state": {
        "algo": 10000000000000,
        "onl": 2
      }
    },
    {
      "addr": "Y76M3MSY6DKBRHBL7C3...F2QWNPL226CA",
      "comment": "FeeSink",
      "state": {
        "algo": 1000000,
        "onl": 2
      }
    },
    ...
  ],
  "fees": "Y76M3MSY6DKBRHBL7C3NNDX...F2QWNPL226CA",
  "id": "v1.0",
  "network": "mainnet",
  "proto": "https://github.com/algorandfoundation/specs/tree/5615adc36bad610c7f165fa2967f4ecfa75125f0",
  "rwd": "737777777777777777777...77777777UFEJ2CI",
  "timestamp": 1560211200
}
Interacting with Algorand Nodes
#与Algorand节点交互
CLI utilities: 		goal, kmd and algokey
#CLI 工具: 		goal, kmd and algokey
REST API interface: 	algod V2, kmd, indexer
#REST API 接口: 	algod V2, kmd, indexer
Algorand SDKs: 		JavaScript, Python, Java o Go


54
Algorand Indexer - Reading from the blockchain
#Algorand 索引器 - 从区块链读取
The Indexer provides a REST API interface of API calls to query the Algorand blockchain. The Indexer REST APIs retrieves blockchain data from a PostgreSQL database, populated using the Indexer instance connected to an Archival Algorand node that reads blocks’ data. As with the Nodes, the Indexer can be used as a third-party service.
#索引器提供了一个可供API调用的REST API接口以查询Algorand链。索引器REST APIs从PostgreSQL数据库中检索区块链数据，使用连接到读取块数据的Algorand存档节点的索引器实例进行填充。与节点一样，索引器可以被用作一个第三方服务。


55
How to interact with Algorand Node and Indexer
#如何与Algorand节点和索引器交互


56
Algorand Community SDKs
#Algorand社区SDKs
Java
JavaScript
Python
Go
C#
Rust
Dart
PHP
Algorand SDKs
Swift


57
Algorand Developer Portal
#Algorand 开发者门户


58
Awesome Algorand


59
Algorand Wallets
#Algorand 钱包
Mobile Wallet + Wallet Connect
#移动钱包+钱包关联
MyAlgo Wallet
AlgoSigner

60
Algorand Explorers
#Algorand浏览器


61
ALGORAND INTEROPERABILITYState Proofs and Post-Quantum Security
Credits to Noah Grossman for contens

Trustless interoperability
62
Algorand approach to interoperability:
cross-chain transactions should rely just on
Trust in departing consensus protocol
Trust in arrival consensus protocol
without centralized bridges or validator networks, to handle the assets.

Algorand State Proofs remove trusted centralized operators becoming the first trustless post-quantum secure L1 interoperability standard.


Post-Quantum Secure Algorand State Proofs
63
Post-Quantum secure and immutable proofs, attesting blockchain state, generated by Pure Proof of Stake consensus protocol.


64
ALGORAND TRANSACTIONS
#ALGORAND交易
Core element of blocks
#块的核心元素

Changing blockchain state
#修改区块链的状态
65
Transactions are the core element of blocks, which define the evolution of distributed ledger state. There are six transaction types in the Algorand Protocol:
Payment
Key Registration
Asset Configuration
Asset Freeze
Asset Transfer
Application Call

These six transaction types can be specified in particular ways that result in more granular perceived transaction types.


Signature, fees and round validity
66
In order to be approved, Algorand’s transactions must comply with:

Signatures: transactions must be correctly signed by its sender, either a Single Signature, a Multi Signature or a Smart Signature / Smart Contract
Fees: in Algorand transactions fees are a way to protect the network from DDoS. In Algorand Pure PoS fees are not meant to pay “validation” (as it happens in PoW blockchains). In Algorand you can delegate fees.
Round validity: to handle transactions’ idempotency, letting Non-Archival nodes participate in Algorand Consensus, transactions have an intrinsic validity of 1000 blocks (at most). 


Browse through a transaction
67
Transactions are characterized by two kind of fields (codec):

common (header)
specific (type)


Payment Transaction example
68
Here is a transaction that sends 5 ALGO from one account to another on MainNet.


69
ALGORAND ACCOUNTS
Transactions’ Authorization

Signatures
70
SECRET KEY
32 bytes
PUBLIC KEY
32 bytes
Ed25519
GENERATOR
Algorand uses Ed25519 high-speed, high-security elliptic-curve signatures.
ALGORAND ADDRESS
58 characters
MNEMONIC PHRASE
25 words
RANDOM SEED
ADDRESS: the public key is transformed into an Algorand Address, by adding a 4-byte checksum to the end of the public key and then encoding it in base32.

MNEMONIC: the 25-word mnemonic is generated by converting the private key bytes into 11-bit integers and then mapping those integers to the bip-0039 English word list.


Algorand Accounts
71
Accounts are entities on the Algorand blockchain associated with specific on-chain local sate. An Algorand Address is the unique identifier for an Algorand Account.
All the potential keys pairs “already exists” mathematically, we just keep discovering them.


Transactions Authorization and Rekey-To
72
PUBLIC ADDRESS
MULTI SIGNATURE ACCOUNT
LOCAL STATE
SECRET KEY [1/N]
PUBLIC ADDRESS
STANDARD ACCOUNT
LOCAL STATE
SECRET KEY
CONTRACT ACCOUNT
SECRET KEY [k/N]
SECRET KEY [N/N]
Algorand Rekeying: powerful Layer-1 protocol feature which enables an Algorand account to maintain a static public address while dynamically rotating the authoritative private spending key(s). Any Account can Rekey either to a Standard Account, MultiSig Account or LogicSig Contract Account.
PUBLIC ADDRESS
SMART SIG
LOCAL STATE


Account State Minimum Balance
73


74
ALGORAND VIRTUAL MACHINE (AVM)Programming on Algorand

What’s a Smart Contract ?
75
Smart Contracts are deterministic programs through which complex decentralized trustless applications can be executed on the AVM.
The Algorand Virtual Machine is a Turing-complete secure execution environment that runs on Algorand consensus layer.
What’s the AVM ?


Algorand Virtual Machine purpose: approving or rejecting transactions’ effects on the blockchain according to Smart Contracts’ logic.
What the AVM actually does?
76
AVM approves transactions’ effects if and only if:
There is a single non-zero value on top of AVM’s stack;
AVM rejects transactions’ effects if and only if:
There is a single zero value on top of AVM’s stack;
There are multiple values on the AVM’s stack;
There is no value on the AVM’s stack;


How the AVM works?
77
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
[...]
[...]
[...]
[...]
[...]
STACK MACHINE


How the AVM works?
78
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
1
[...]
[...]
[...]
[...]
STACK MACHINE
pushing first operand


How the AVM works?
79
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
2
1
[...]
[...]
[...]
STACK MACHINE
pushing
second operand


How the AVM works?
80
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
2
1
[...]
[...]
[...]
STACK MACHINE
applying
operator


How the AVM works?
81
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
3
[...]
[...]
[...]
[...]
STACK MACHINE


How the AVM works?
82
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
3
3
[...]
[...]
[...]
STACK MACHINE
pushing
last operand


How the AVM works?
83
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
3
3
[...]
[...]
[...]
STACK MACHINE
applying
operator


How the AVM works?
84
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
true
[...]
[...]
[...]
[...]
STACK MACHINE


AVM architecture
85
Sender
Receiver
Fee
FirstValid
LastValid
Amount
Lease
Note
TypeEnum
… 
[0]:    Bytes
[i]:    Bytes
[255]:  Bytes
TRANSACTION
TRANSACTION ARGS
[0]:  UInt64 / Bytes
[i]:  UInt64 / Bytes
[63]: UInt64 / Bytes
APP GLOBAL K/V PAIRS
[0]:  UInt64 / Bytes
[i]:  UInt64 / Bytes
[15]: UInt64 / Bytes
APP LOCAL K/V PAIRS
[0]:  UInt64/ Bytes
[i]:  UInt64/ Bytes
[15]: UInt64/ Bytes
[0]:  Bytes
[i]:  Bytes
[3]:  Bytes
[0]:  UInt64
[i]:  UInt64
[7]:  UInt64
APP IDs ARRAY
ACCOUNT ARRAY
APP ARG ARRAY
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
&&
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
txn Amount
int 42
==
txn Amount
int 77
==
||
&&
PROGRAM
[0]:    UInt64 / Bytes
[i]:    UInt64 / Bytes
[999]:  UInt64 / Bytes
STACK MACHINE
[0]:    UInt64 / Bytes
[i]:    UInt64 / Bytes
[255]:  UInt64 / Bytes
SCRATCH SPACE
[0]:  UInt64
[i]:  UInt64
[7]:  UInt64
ASSET ARRAY
Stateless properties
Stateful properties
Processing
Max Key + Value size: 128 bytes


NODE
COMPILERS
IDEs
How to program the AVM?
86
Algorand Virtual Machine (AVM)
TEAL
AVM Bytecode
PyTeal
TEAL
AVM Bytecode
Reach Lang
TEAL
AVM Bytecode
TEAL
AVM Bytecode
Languages...
...
...
...


AVM vs EVM
87
Algorand Virtual Machine
Ethereum Virtual Machine
TURING COMPLETENESS
YES
YES
EXECUTION SPEED
~ 4.5 sec
regardless dApp complexity
> 20 sec
depends on dApp complexity
ENERGY EFFICIENCY
~10-5 [kWh/txn]
all final
~102 [kWh/txn]
not all final
EXECUTION COSTS
~ 0.001 $ (public network)
regardless dApp complexity
~ 20 $ (public network)
depends on dApp complexity
INTEROPERABILITY
native interoperability
ASA, AT, MultiSig, RekeyTo...
user defined solutions / standards
EFFECTS FINALITY
instant
~ 6 blocks
MATHEMATICAL PRECISION
512 bits
256 bits
PROGRAMMABILITY
TEAL, PyTEAL, Reach, ...
Solidity, Viper, Reach, ...


What can be built on the AVM?
88
Escrow accounts
KYC processes
Financial instruments (Bonds, ETFs, etc.)
Loan payment
Voting applications
Auctions
Multiparty or Delegated fund management
Programmatic recurring fees / recurring debt
And more...


89
ASC1Algorand Smart Contracts on Layer-1

AVM Modes
90
ASC1
Mode 1:
SMART SIGNATURE
(Stateless)
Mode 2:
SMART CONTRACTS
(Stateful)


Mode 1:
SMART SIGNATURE
(Stateless)
Stateless ASC1
91
ASC1
Mode 2:
APPLICATION
(Stateful)
Contract
Account
Application
Smart Signatures are programs whose logic governs transactions’ authorization.
Domain: transient properties
“Stateless ASC1 deal with assets’ spending approvals”
Delegated
Signature


Stateful ASC1
92
ASC1
Mode 1:
LOGIC SIGNATURE
(Stateless)
Contract
Account
Application
Delegated
Signature
Smart Contracts are programs whose logic reads and writes blockchain’s state, creates and submits transactions.
Domain: persistent properties
“Stateful ASC1 deal with accounts’ state changes”
Mode 2:
SMART CONTRACTS
(Stateful)


93
SMART SIGNATURESAuthorizing transactions through TEAL logic

Creating Smart Signature
94
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
&&
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
txn Amount
int 42
==
txn Amount
int 77
==
||
&&
PROGRAM
NODE
SMART SIGNATURE
CONTRACT PUBLIC ADDRESS
Compiled TEAL Max Size: 1000 bytes
OpCode Max Budget: 20.000


Contract Account
95
CONTRACT ACCOUNT

ASC1 PUBLIC ADDRESS
LOCAL STATE
STANDARD / MULTISIG
ACCOUNT
TRANSACTION
SMART SIGNATURE
STANDARD / MULTISIG
ACCOUNT
funds...
appends...
binding


Delegated Signature
96
STANDARD / MULTISIG
ACCOUNT
SMART SIGNATURE
DELEGATED SIGNATURE
TRANSACTION
STANDARD / MULTISIG
ACCOUNT
STANDARD / MULTISIG
ACCOUNT
signs...
appends...
PUBLIC ADDRESS
SECRET KEY
binding


97
SMART CONTRACTSDecentralized Applications on Algorand

Deploying Applications on chain
98
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
&&
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
txn Amount
int 42
==
txn Amount
int 77
==
||
&&
submits...
PROGRAM
NODE
APPLICATION
CREATE
TRANSACTION
B1
B2
B3
...
Br
BLOCKCHAIN
APPLICATION ID
Compiled TEAL Max Size: 2048 bytes (+3 Extra Pages)
OpCode Max Budget: 700 (x16 Atomic Calls)


Interacting with Applications
99
APPLICATION CALL
TRANSACTION
APPLICATION
(PROGRAM ON-CHAIN)
APP USER
ACCOUNT 1
LOCAL STATE

KYC:    PASSED
APP USER
ACCOUNT 2
LOCAL STATE

KYC:    PENDING
APP USER
ACCOUNT...
LOCAL STATE

KYC:    REJECTED
GLOBAL STATE

INTEREST RATE:    1%
INNER
TRANSACTION
Apps
Arguments
Assets
Accounts
LOG VALUE


100
TEALAVM assembly-like language

Smart Signature Example
101
Suppose we want to develop a Smart Signature that approves a transaction if and only if:

is “Payment” type transaction;
the receiver is a specific “ADDR”;
fees are less or equal to “1000 microALGO”;
first argument is equal to “bianconiglio”;
amount is  equal to “42 ALGO”;
or amount is equal to “77 ALGO”;

Where do we start?


Smart Signature as “Transaction Observer”
102
Smart Signatures can be defined as a “transactions’ observers”: programs that meticulously check all fields in the transaction (or in a group of transactions) that intend to “approve” or “reject” based on TEAL logic.

To translate those 6 semantically defined example’s conditions into TEAL we need to check which transaction fields are going to be controlled by Smart Signature’s logic.



Let's start with the translation...


Translating conditions into TEAL…
103
is “Payment” type transaction;
txn TypeEnum
int 1
==
1


104
the receiver is a specific “ADDR”;
txn Receiver
addr AOC7...
==
2
Translating conditions into TEAL…


105
fees are less or equal to “1000 microALGO”;
txn Fee
int 1000
<=
3
Translating conditions into TEAL…


106
first argument is equal to “bianconiglio”;
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
4
Translating conditions into TEAL…


107
amount is  equal to “42 ALGO”;
txn Amount
int 42000000
==
5
Translating conditions into TEAL…


108
amount is  equal to “77 ALGO”;
txn Amount
int 77000000
==
6
Translating conditions into TEAL…


109
Logic connectors…
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
[...]
[...]
STACK
[...]
[...]
[...]
1
2
3
4
5
6


110
Logic connectors…
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
[...]
[...]
STACK
[...]
[...]
[...]
1
2
3
4
5
6
This is probably the most complex phase in TEAL programming, because you need to keep in mind the state of the stack.

This phase is drastically simplified with the use of PyTEAL, Python binding for TEAL, which automatically performs this concatenation, saving us the effort of thinking about the state of the stack.


111
Execution…
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
[...]
[...]
[...]
[...]


145
Conclusion…
1
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
STACK
[...]
[...]
[...]
[...]
True


146
PyTEALWriting Smart Contracts with Python
Credits to Jason Paulos for the PyTEAL presentation

What’s PyTEAL?
147
PyTEAL is a Python language binding for Algorand Virtual Machine.
PyTEAL allows Smart Contracts and Smart Signatures to be written in Python and then compiled to TEAL.


148
It’s easier with PyTEAL!
TEAL Source Code
txn Receiver
addr AOC7...
==
txn Amount
int 1000
<=
&&
COMPILE...
AVM bytecode
PyTEAL Source Code
And(
Txn.Receiver == Addr(AOC7...),
    	Txn.Amount <= Int(1000),
)

TEAL Source Code
txn Receiver
addr AOC7...
==
txn Amount
int 1000
<=
&&
COMPILE...
COMPILE...
AVM bytecode


149
Smart Signature written in PyTEAL


PyTEAL Basics - Intro
150
PyTEAL expressions represent an abstract syntax tree (AST)
You’re writing Python code that produces TEAL code.
from pyteal import *

program = ...
teal_source = compileTeal(program, mode=Mode.Application, version=5)


PyTEAL Basics - Types (1/2)
151
Two basic types:
uint64
byte strings
i = Int(5)
x = Bytes("content")
y = Bytes(b"\x01\x02\x03")
z = Bytes("base16", "05")


PyTEAL Basics - Types (2/2)
152
Conversion between types
Itob - integer to bytes (8-byte big endian)
Btoi - bytes to integer
Itob(i) # produces the byte string 0x0000000000000005
Btoi(z) # produces the integer 5


PyTEAL Basics - Math operators
153
Python math operators
i = Int(10)
j = i * Int(2) + Int(1)
k = And(Int(1), Or(Int(1), Int(0)))


PyTEAL Basics - Byte string manipulation
154
Byte string manipulation
x = Bytes("content")
y = Concat(Bytes("example "), x) # "example content"
z = Substring(y, Int(2), Len(y)) # "ample content"


PyTEAL Basics - Crypto utilities
155
Built-in crypto utilities
h_sha256 = Sha256(z)
h_sha512_256 = Sha512_256(z)
h_keccak = Keccak256(z)


PyTEAL Basics - Fields (1/3)
156
Fields from the current transaction
Txn.sender()
Txn.accounts.length()
Txn.application_args.length()
Txn.accounts[1]
Txn.application_args[0]
Txn.group_index()


PyTEAL Basics - Fields (2/3)
157
Fields from transactions in the current atomic group
Gtxn[0].sender()
Gtxn[Txn.group_index() - Int(1)].sender()
Gtxn[Txn.group_index() - Int(1)].accounts[2]


PyTEAL Basics - Fields (3/3)
158
Fields from execution context
Global.group_size()
Global.round() # current round number
Global.latest_timestamp() # UNIX timestamp of last round


PyTEAL Basics - Logs
159
Log publicly viewable messages to the chain
	Log(Bytes("message"))


PyTEAL Basics - State (1/2)
160
Global - one instance per application
App.globalPut(Bytes("status"), Bytes("active")) # write to global key "status"

status = App.globalGet(Bytes("status")) # read global key "status"

App.globalDel(Bytes("status")) # delete global key "status"


PyTEAL Basics - State (2/2)
161
Local - one instance per opted-in account per application
App.localPut(Txn.sender(), Bytes("level"), Int(1)) # write to sender's local key "level"
App.localPut(Txn.accounts[1], Bytes("level"), Int(2))  # write to other account's local key "level"

sender_level = App.localGet(Txn.sender(), Bytes("level"))  # read from sender's local key "level"

App.localDel(Txn.sender(), Bytes("level"))  # delete sender's local key "level"


PyTEAL Basics - Control Flow (1/5)
162
Approve the transaction and immediately exit
Approve()
Reject the transaction and immediately exit
Reject()


PyTEAL Basics - Control Flow (2/5)
163
Multiple expressions can be joined into a sequence
program = Seq(
   App.globalPut(Bytes("count"), App.globalGet(Bytes("count")) + Int(1)),
   Approve()
)


PyTEAL Basics - Control Flow (3/5)
164
Basic conditions can be expressed with If, Then, Else, ElseIf
program = Seq(
   If(App.globalGet(Bytes("count")) == Int(100))
   .Then(
       App.globalPut(Bytes("100th caller"), Txn.sender())
   )
   .Else(
       App.globalPut(Bytes("not 100th caller"), Txn.sender())
   ),
   App.globalPut(Bytes("count"), App.globalGet(Bytes("count")) + Int(1)),
   Approve(),
)


PyTEAL Basics - Control Flow (4/5)
165
Larger conditions can be expressed with Cond
program = Cond(
   [Txn.application_id() == Int(0), on_create],
   [Txn.on_completion() == OnComplete.UpdateApplication, on_update],
   [Txn.on_completion() == OnComplete.DeleteApplication, on_delete],
   [Txn.on_completion() == OnComplete.OptIn, on_opt_in],
   [Txn.on_completion() == OnComplete.CloseOut, on_close_out],
   [Txn.on_completion() == OnComplete.NoOp, on_noop],
   # error if no conditions are met
)


PyTEAL Basics - Control Flow (5/5)
166
Loops can be expressed with For and While
i = ScratchVar(TealType.uint64)

on_create = Seq(
   For(i.store(Int(0)), i.load() < Int(16), i.store(i.load() + Int(1)))
   .Do(
       App.globalPut(Concat(Bytes("index"), Itob(i.load())), Int(1))
   ),
   Approve(),
)


PyTEAL Basics - Subroutines (1/2)
167
Sections of code can be put into subroutines (Python decorators)
@Subroutine(TealType.uint64)
def isEven(i):
   return i % Int(2) == Int(0)

App.globalPut(Bytes("value_is_even"), isEven(Int(10)))


PyTEAL Basics - Subroutines (2/2)
168
Recursion is allowed
@Subroutine(TealType.uint64)
def recursiveIsEven(i):
   return (
       If(i == Int(0))
       .Then(Int(1))
       .ElseIf(i == Int(1))
       .Then(Int(0))
       .Else(recursiveIsEven(i - Int(2)))
   )


PyTEAL Basics - Inner Transactions (1/3)
169
Every application has control of an account
Global.current_application_address()


PyTEAL Basics - Inner Transactions (2/3)
170
Applications can send transactions from this account
Seq(
   InnerTxnBuilder.Begin(),
   InnerTxnBuilder.SetFields(
       {
           TxnField.type_enum: TxnType.Payment,
           TxnField.receiver: Txn.sender(),
           TxnField.amount: Int(1_000_000),
       }
   ),
   InnerTxnBuilder.Submit() # send 1 Algo from the app account to the transaction sender
)


PyTEAL Basics - Inner Transactions (3/3)
171
appAddr = Global.current_application_address()
Seq(
   InnerTxnBuilder.Begin(),
   InnerTxnBuilder.SetFields(
       {
           TxnField.type_enum: TxnType.AssetConfig,
           TxnField.config_asset_name: Bytes("PyTEAL Coin"),
           TxnField.config_asset_unit_name: Bytes("PyTEAL"),
           TxnField.config_asset_url: Bytes("https://pyteal.readthedocs.io/"),
           TxnField.config_asset_decimals: Int(6),
           TxnField.config_asset_total: Int(800_000_000),
           TxnField.config_asset_manager: appAddr,
       }
   ),
   InnerTxnBuilder.Submit(), # create a PyTEAL Coin asset
   App.globalPut(Bytes("PyTealCoinId"), InnerTxn.created_asset_id()) # remember the asset ID
)


A pythonic Algorand stack
172
Algorand Python SDK
PyTEAL
PyTest for Smart Contracts unit-tests and e2e-tests
TEAL Debugger
Algorand Sandbox Docker in dev mode
PyCharm IDE & AlgoDEA plug-in


“Zero to Hero PyTEAL” crash course
173
Join and learn in 12 lessons!


174
DAPP EXAMPLE & USE CASESExample: zero coupon bond

Zero coupon bond
175
Bondholder purchase a bond (only if KYC has been passed)
Bond application checks for bond’s maturity
Bond Issuer re-pays the Bondholder at given rate


BONDHOLDER
ACCOUNT
BOND ESCROW
CONTRACT ACCOUNT
Zero coupon bond
176
Bondholder purchase a bond (only if KYC has been passed)
BOND
APPLICATION
ATOMIC TRANSACTION

BOND
APPLICATION CALL
CBDC TRANSFER TRANSACTION
BOND TRANSFER TRANSACTION
CBDC
BOND
KYC
APPLICATION
LOCAL STATE

KYC:    PASSED


reads


BONDHOLDER
ACCOUNT
Zero coupon bond
177
Bond application checks for bond’s maturity
BOND ESCROW
CONTRACT ACCOUNT
LOCAL STATE

KYC:    PASSED

BOND MATURE:   NO
BOND
reads
CBDC
BOND
APPLICATION


Zero coupon bond
178
Bond Issuer re-pays the Bondholder at given rate
ATOMIC TRANSACTION

BOND ESCROW
CONTRACT ACCOUNT
BONDHOLDER
ACCOUNT
BOND APPLICATION CALL
BOND TRANSFER TRANSACTION
CBDC TRANSFER TRANSACTION
BOND
APPLICATION
BOND ISSUER
ACCOUNT
CBDC
GLOBAL STATE

INTEREST RATE:    1%
LOCAL STATE

KYC:    PASSED

BOND MATURE:   YES
BOND


Thanks to the contributors!

Jason Paulos
Pietro Grassano
