Algorand School

2022


Cosimo Bassi
Solutions Architect at Algorand Inc.

cosimo.bassi@algorand.com

Our journey today:

understanding Algorand Consensus and Algorand Networks, how to use Algorand Dev Tools, how to develop decentralized applications on the Algorand Virtual Machine

Agenda

Algorand Consensus
Algorand Decentralized Governance
Algorand Networks
Algorand Transactions
Algorand Accounts
Algorand Virtual Machine
Algorand Smart Contracts on Layer-1
Smart Signatures & Smart Contracts
TEAL
PyTEAL
dApp Example & Use Cases

4
ALGORAND CONSENSUSPure Proof of Stake (PPoS)

What is a blockchain?
5
A blockchain is a public ledger of transactional data, distributed across a system of multiple nodes in a network.

All these nodes work together, using the same set of software and rules, to verify the transactions to add to the finalized ledger. This set of rules is called consensus protocol.

The ledger is publicly verifiable, permissionless and tamper-proof.


What is a blockchain?
6
The “block” refers to a set of transactions that are proposed and verified by the other nodes and eventually added to the ledger.
The “chain” refers to the fact that each block of transactions also contains proof (a cryptographic hash) of what was in the previous block.


The architecture of consensus
7
Temple of Concordia
Valley of Temples (Agrigento), 440-430 B.C.
How to choose the proposer for the next block for a public and permissionless blockchain?

How to ensure that there is no ambiguity in the choice of the next block?

How to ensure that the blockchain stays unique and has no forks?

How to ensure that consensus mechanism itself can evolve over time while the blockchain is an immutable ledger?


Consensus mechanisms
8
CRITICAL ISSUES
PROOF OF WORK
Miners compete with each other to append the next block and earn a reward for the effort, fighting to win an expensive computational battle.
Huge electrical consumption
Concentration of governance in few mining farms
Soft-forking of the blockchain
BONDED PROOF OF STAKE
Validators bind their stake, to show their commitment in validating and appending a new block. Misbehaviors are punished.
Participating in the consensus protocol makes users’ stakes illiquid
Risk of economic barrier to entry
DELEGATED PROOF OF STAKE
Users delegate the validation of new blocks to a fixed committee, through weighted voting based on their stakes.
Known delegate nodes, therefore exposed to DDoS attacks
Centralization of governance
PoW
BPoS
DPoS


Is the Blockchain Trilemma unsolvable?
9
TRILEMMA
2
3
1
SECURITY
SCALABILITY
DECENTRALIZATION


Scalable		billions of users
Efficient		1000 TPS (10x work in progress)
Fast			< 5s per block
Low fees		0.001 ALGO per txn
No Soft Forks 	prob. < 10-18
Instant Transaction Finality
Minimal hardware node requirements
No delegation or binding of the stake
No minimum stake
Carbon negative
Secure with respect DDoS
Network Partitioning resilience
Algorand PPoS Consensus
10
Silvio Micali  Algorand Founder
Professor MIT, Turing Award, Gödel Prize
Digital Signatures, Probabilistic Encryption, Zero-Knowledge Proofs,
Verifiable Random Functions and other primitives of modern cryptography.



Who chose the next block?
11
VRF
VRF
VRF
VRF
WIN!
Each online ALGO could be assimilated to a ticket participating in a safe and secret cryptographic sortition

For each new block, tickets’ draw is performed in a distributed, parallel and secret and manner, directly on online accounts’ hardware (in microseconds)

The winner is revealed in a safe and verifiable way only after winning the draw, proposing the next block


A glimpse on “simplified” VRF sortition
12
A secret key (SK) / public verification key (VK) pair is associated with each ALGO in the account
For each new round r of the consensus protocol a threshold L(r) is defined
Each ALGO in the account performs a VRF, using its own secret key (SK), to generate:
a pseudo-random number:		Y = VRFSK(seed)
the verifiable associated proof:	⍴SK(seed)
If Y = VRFSK(seed) < L(r), that specific ALGO “wins the lottery” and viraly propagates the proof of its victory ⍴SK(seed) to other network’s nodes, through “gossiping” mechanism
Others node can use the public verification key (VK) to verify, through ⍴SK(seed), that the number Y was generated by that specific ALGO, owned by the winner of the lottery


Pure Proof of Stake, in short
13
Through the cryptographic lottery, an online account is elected with probability directly proportional to its stake: each ALGO corresponds to an attempt to win the lottery!




An account is elected to propose the next block
A committee is elected to filter and vote on the block proposals
A new committee is elected to reach a quorum and certify the block
The new block is appended to the blockchain
Each round of the consensus protocol appends a new block in the blockchain:


Pure Proof of Stake security
14
Algorand’s decentralized Byzantine consensus protocol can tolerate an arbitrary number of malicious users as long as honest users hold a super majority of the total stake in the system.
The adversary does not know which users he should corrupt.
The adversary realizes which users are selected too late to benefit from attacking them. 
Each new set of users will be privately and individually elected.
During a network partition in Algorand, the adversary is never able to convince two honest users to accept two different blocks for the same round.
Algorand is able to recover shortly after network partition is resolved and guarantees that new blocks will be generated at the same speed as before the partition.


Pure Proof of Stake, some numbers
15
BLOCKS
> 18 M with 0 downtime
BLOCKCHAIN SIZE
~ 900 GB
ADDRESSES
> 18 M with ~ 6 M monthly active addresses
AVG. BLOCK FINALIZATION
~ 4,4 sec per block
TXNS VOLUME MONTHLY PEAK
~ 40 M transactions (March 2021)
TPS WEEKLY PEAK
~ 1150 transactions per second
* up to January 2022


Algorand Layer-1 primitives
16

Algorand Standard Assets (ASA)

Atomic Transfers
(AT)

Algorand Smart Contracts (ASC1)






17
DECENTRALIZED GOVERNANCEGoverning ALGO

ALGO Decentralized Governance
18
Decentralized Governors
Vote on-chain, each quarter, by staking their ALGO-votes in governance.
Decide how the AERP should be utilised and distributed, to support the long term development of the Algorand network.
Are rewarded for their efforts, based on their stake in governance.
Decentralized Governance over Algorand Ecosystem Resource Pool (AERP), including Ecosystem Support, Participation Incentives and Contingent Rewards (total of 3,2B ALGOs) previously entrusted to the Algorand Foundation.


The ALGO
19
* January 2022
GENESIS BLOCK
Main Net, June 2019
GENESIS HASH
wGHE2Pwdvd7S12BL5FaOP20EGYesN73ktiC1qzkkit8=
TOTAL SUPPLY (fixed)
10 B ALGO
MINIMAL UNIT
1 microALGO = 10-6 ALGO
CIRCULATING SUPPLY
~ 6,5 B ALGO
PPoS PARTICIPATING STAKE
~ 2,1 B ALGO
GOVERNANCE STAKE
~ 3,2 B ALGO
GOVERNORS
~ 65 k


20
ALGORAND NETWORKSNodes, Indexer and APIs

Algorand Node configurations
21
Non-Relay Nodes
Participate in the PPoS consensus (if hosting participation keys)
Connect only to Relay Nodes 
Light Configuration: store just the lastest 1000 blocks (Fast Catch-Up)
Archival Configuration: store all the chain since the genesis block

Relay Nodes
Communication routing to a set of connected Non-Relay Nodes
Connect both with Non-Relay Nodes and Relay Nodes
Route blocks to all connected Non-Relay Nodes
Highly efficient communication paths, reducing communication hops


Example of Algorand Network topology
22
Node Metrics
Non-Relay Nodes: 	> 1600
Relay Nodes:		> 120


23
Access to Algorand Network
The Algorand blockchain is a distributed system of nodes each maintaining their local state based on validating the history of blocks and the transactions therein. Blockchain state integrity is maintained by the consensus protocol which is implemented within the Algod daemon (often referred to as the node software).

An application connects to the Algorand blockchain through an Algod client, requiring:

a valid Algod REST API endpoint IP address
an Algod token from an Algorand node connected to the network you plan to interact with

These two pieces of information can be provided by your local node or by a third party node aaS.


24
How to get an Algod Client?
There are three ways to get a REST API Algod endpoint IP address / access token, each with their respective pros and cons depending on development goals.


25
Algorand Networks


26
Algorand Node -  Writing on the blockchain
Install (Linux, MacOS, Windows)
Choose a network (MainNet, TestNet, BetaNet, PrivateNet)
Start & Sync with the network, Fast Catchup

genesis.json (mainnet)

{
  "alloc": [
    {
      "addr": "7377777777777777...77777777UFEJ2CI",
      "comment": "RewardsPool",
      "state": {
        "algo": 10000000000000,
        "onl": 2
      }
    },
    {
      "addr": "Y76M3MSY6DKBRHBL7C3...F2QWNPL226CA",
      "comment": "FeeSink",
      "state": {
        "algo": 1000000,
        "onl": 2
      }
    },
    ...
  ],
  "fees": "Y76M3MSY6DKBRHBL7C3NNDX...F2QWNPL226CA",
  "id": "v1.0",
  "network": "mainnet",
  "proto": "https://github.com/algorandfoundation/specs/tree/5615adc36bad610c7f165fa2967f4ecfa75125f0",
  "rwd": "737777777777777777777...77777777UFEJ2CI",
  "timestamp": 1560211200
}
Interacting with Algorand Nodes
CLI utilities: 		goal, kmd and algokey
REST API interface: 	algod V2, kmd, indexer
Algorand SDKs: 		JavaScript, Python, Java o Go


27
Algorand Indexer - Reading from the blockchain
The Indexer provides a REST API interface of API calls to query the Algorand blockchain. The Indexer REST APIs retrieves blockchain data from a PostgreSQL database, populated using the Indexer instance connected to an Archival Algorand node that reads blocks’ data. As with the Nodes, the Indexer can be used as a third-party service.


28
How to interact with Algorand Node and Indexer


29
Algorand Community SDKs
Java
JavaScript
Python
Go
C#
Rust
Dart
PHP
Algorand SDKs
Swift


30
Algorand Developer Portal


31
Awesome Algorand


32
Algorand Wallets
Mobile Wallet + Wallet Connect
MyAlgo Wallet
AlgoSigner


33
Algorand Explorers


34
ALGORAND TRANSACTIONS
Core element of blocks

Changing blockchain state
35
Transactions are the core element of blocks, which define the evolution of distributed ledger state. There are six transaction types in the Algorand Protocol:
Payment
Key Registration
Asset Configuration
Asset Freeze
Asset Transfer
Application Call

These six transaction types can be specified in particular ways that result in more granular perceived transaction types.


Signature, fees and round validity
36
In order to be approved, Algorand’s transactions must comply with:

Signatures: transactions must be correctly signed by its sender, either a Single Signature, a Multi Signature or a Smart Signature / Smart Contract
Fees: in Algorand transactions fees are a way to protect the network from DDoS. In Algorand Pure PoS fees are not meant to pay “validation” (as it happens in PoW blockchains). In Algorand you can delegate fees.
Round validity: to handle transactions’ idempotency, letting Non-Archival nodes participate in Algorand Consensus, transactions have an intrinsic validity of 1000 blocks (at most). 


Browse through a transaction
37
Transactions are characterized by two kind of fields (codec):

common (header)
specific (type)


Payment Transaction example
38
Here is a transaction that sends 5 ALGO from one account to another on MainNet.


39
ALGORAND ACCOUNTS
Transactions’ Authorization

Signatures
40
SECRET KEY
32 bytes
PUBLIC KEY
32 bytes
Ed25519
GENERATOR
Algorand uses Ed25519 high-speed, high-security elliptic-curve signatures.
ALGORAND ADDRESS
58 characters
MNEMONIC PHRASE
25 words
RANDOM SEED
ADDRESS: the public key is transformed into an Algorand Address, by adding a 4-byte checksum to the end of the public key and then encoding it in base32.

MNEMONIC: the 25-word mnemonic is generated by converting the private key bytes into 11-bit integers and then mapping those integers to the bip-0039 English word list.


Algorand Accounts
41
Accounts are entities on the Algorand blockchain associated with specific on-chain local sate. An Algorand Address is the unique identifier for an Algorand Account.
All the potential keys pairs “already exists” mathematically, we just keep discovering them.


Transactions Authorization and Rekey-To
42
PUBLIC ADDRESS
MULTI SIGNATURE ACCOUNT
LOCAL STATE
SECRET KEY [1/N]
PUBLIC ADDRESS
STANDARD ACCOUNT
LOCAL STATE
SECRET KEY
CONTRACT ACCOUNT
SECRET KEY [k/N]
SECRET KEY [N/N]
Algorand Rekeying: powerful Layer-1 protocol feature which enables an Algorand account to maintain a static public address while dynamically rotating the authoritative private spending key(s). Any Account can Rekey either to a Standard Account, MultiSig Account or LogicSig Contract Account.
PUBLIC ADDRESS
SMART SIG
LOCAL STATE


43
ALGORAND VIRTUAL MACHINE (AVM)Programming on Algorand

What’s a Smart Contract ?
44
Smart Contracts are deterministic programs through which complex decentralized trustless applications can be executed on the AVM.
The Algorand Virtual Machine is a Turing-complete secure execution environment that runs on Algorand consensus layer.
What’s the AVM ?


Algorand Virtual Machine purpose: approving or rejecting transactions’ effects on the blockchain according to Smart Contracts’ logic.
What the AVM actually does?
45
AVM approves transactions’ effects if and only if:
There is a single non-zero value on top of AVM’s stack;
AVM rejects transactions’ effects if and only if:
There is a single zero value on top of AVM’s stack;
There are multiple values on the AVM’s stack;
There is no value on the AVM’s stack;


How the AVM works?
46
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
[...]
[...]
[...]
[...]
[...]
STACK MACHINE


AVM architecture
54
Sender
Receiver
Fee
FirstValid
LastValid
Amount
Lease
Note
TypeEnum
… 
[0]:    Bytes
[i]:    Bytes
[255]:  Bytes
TRANSACTION
TRANSACTION ARGS
[0]:  UInt64 / Bytes
[i]:  UInt64 / Bytes
[63]: UInt64 / Bytes
APP GLOBAL K/V PAIRS
[0]:  UInt64 / Bytes
[i]:  UInt64 / Bytes
[15]: UInt64 / Bytes
APP LOCAL K/V PAIRS
[0]: UInt64/ Bytes
[i]: UInt64/ Bytes
[15]:UInt64/ Bytes
[0]:    Bytes
[i]:    Bytes
[3]:    Bytes
[0]:   UInt64
[1]:   UInt64
APP IDs ARRAY
ACCOUNT ARRAY
APP ARG ARRAY
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
&&
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
txn Amount
int 42
==
txn Amount
int 77
==
||
&&
PROGRAM
[0]:    UInt64 / Bytes
[i]:    UInt64 / Bytes
[999]: UInt64 / Bytes
STACK MACHINE
[0]:    UInt64 / Bytes
[i]:    UInt64 / Bytes
[255]:  UInt64 / Bytes
SCRATCH SPACE
[0]:   UInt64
[1]:   UInt64
ASSET ARRAY
Stateless properties
Stateful properties
Processing


NODE
COMPILERS
IDEs
How to program the AVM?
55
Algorand Virtual Machine (AVM)
TEAL
AVM Bytecode
PyTeal
TEAL
AVM Bytecode
Reach Lang
TEAL
AVM Bytecode
TEAL
AVM Bytecode
Languages...
...
...
...


Latest release: AVM 0.9
56
The AVM now supports looping and subroutines.
Sharing data between SCs when combing contract calls in Atomic Transfers.
Delegating transaction fees using pooled transaction fees in Atomic Transfers.
AVM dynamic opcode cost evaluation, allowing larger and more modular SCs.
Much larger Stateful Smart Contracts (up to 8kb of program).
More versatile application transaction array indexes.
Customizable global and local state key/value pairs, to maximize storage.
Larger URLs for Algorand Standard Assets (up to 96 bytes).
More precision: 512 bit math operations for byteslice arithmetic.
Many additional TEAL opcodes (including more advanced math operators).


AVM vs EVM
57
Algorand Virtual Machine
Ethereum Virtual Machine
TURING COMPLETENESS
YES
YES
EXECUTION SPEED
~ 4.5 sec
regardless dApp complexity
> 20 sec
depends on dApp complexity
ENERGY EFFICIENCY
0.000008 [kWh/txn]
all final
120 [kWh/txn]
not all final
EXECUTION COSTS
~ 0.001 $ (public network)
regardless dApp complexity
~ 20 $ (public network)
depends on dApp complexity
INTEROPERABILITY
native interoperability
ASA, AT, MultiSig, RekeyTo...
user defined solutions / standards
EFFECTS FINALITY
instant
~ 6 blocks
MATHEMATICAL PRECISION
512 bits
256 bits
PROGRAMMABILITY
TEAL, PyTEAL, Reach, ...
Solidity, Viper, Reach, ...


What can be built on the AVM?
58
Escrow accounts
KYC processes
Financial instruments (Bonds, ETFs, etc.)
Loan payment
Voting applications
Auctions
Multiparty or Delegated fund management
Programmatic recurring fees / recurring debt
And more...


59
ASC1Algorand Smart Contracts on Layer-1

What does execution on Layer-1 mean?
60
Smart Contracts are executed “at consensus level”
Benefit from network's speed, security, and scalability
Fast trustless execution (~4.5 seconds per block)
Low cost execution (0.001 ALGO regardless SC’s complexity)
Instant Finality of Smart Contracts’ effects
Native interoperability with Layer-1 primitives
Safe high level languages (PyTeal, Reach, Clarity)
Low energy consumption


What does execution on Layer-1 mean?
61
B1
B2
...
Br
ASC1 CALL
ASC1 CALL
ASC1 CALL
TXN 1
ASC1 CALL
L-1 CONSENSUS COMMITTEE

4.5 sec
L-1 CONSENSUS COMMITTEE

4.5 sec
L-1 CONSENSUS COMMITTEE

4.5 sec
EXECUTION ON PPoS CONSENSUS LEVEL
up to 5000 txn/block
up to 5000 txn/block
ASC1 execution does not slow down the whole blocks production
up to 5000 txn/block
up to 5000 txn/block


AVM Modes
62
ASC1
Mode 1:
SMART SIGNATURE
(Stateless)
Mode 2:
SMART CONTRACTS
(Stateful)


Mode 1:
SMART SIGNATURE
(Stateless)
Stateless ASC1
63
ASC1
Mode 2:
APPLICATION
(Stateful)
Contract
Account
Application
Smart Signatures are programs whose logic governs transactions’ authorization.
Domain: transient properties
“Stateless ASC1 deal with assets’ spending approvals”
Delegated
Signature


Stateful ASC1
64
ASC1
Mode 1:
LOGIC SIGNATURE
(Stateless)
Contract
Account
Application
Delegated
Signature
Smart Contracts are programs whose logic reads and writes blockchain’s state, creates and submits transactions.
Domain: persistent properties
“Stateful ASC1 deal with accounts’ state changes”
Mode 2:
SMART CONTRACTS
(Stateful)


65
SMART SIGNATURESAuthorizing transactions through TEAL logic

Creating Smart Signature
66
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
&&
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
txn Amount
int 42
==
txn Amount
int 77
==
||
&&
PROGRAM
NODE
SMART SIGNATURE
CONTRACT PUBLIC ADDRESS


Contract Account
67
CONTRACT ACCOUNT

ASC1 PUBLIC ADDRESS
LOCAL STATE
STANDARD / MULTISIG
ACCOUNT
TRANSACTION
SMART SIGNATURE
STANDARD / MULTISIG
ACCOUNT
funds...
appends...
binding


Delegated Signature
68
STANDARD / MULTISIG
ACCOUNT
SMART SIGNATURE
DELEGATED SIGNATURE
TRANSACTION
STANDARD / MULTISIG
ACCOUNT
STANDARD / MULTISIG
ACCOUNT
signs...
appends...
PUBLIC ADDRESS
SECRET KEY
binding


69
SMART CONTRACTSDecentralized Applications on Algorand

Deploying Applications on chain
70
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
&&
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
txn Amount
int 42
==
txn Amount
int 77
==
||
&&
submits...
PROGRAM
NODE
APPLICATION
CREATE
TRANSACTION
B1
B2
B3
...
Br
BLOCKCHAIN
APPLICATION ID


Interacting with Applications
71
APPLICATION CALL
TRANSACTION
APPLICATION
(PROGRAM ON-CHAIN)
APP USER
ACCOUNT 1
LOCAL STATE

KYC:    PASSED
APP USER
ACCOUNT 2
LOCAL STATE

KYC:    PENDING
APP USER
ACCOUNT...
LOCAL STATE

KYC:    REJECTED
GLOBAL STATE

INTEREST RATE:    1%
INNER
TRANSACTION
Apps
Arguments
Assets
Accounts


72
TEALAVM assembly-like language

Smart Signature Example
73
Suppose we want to develop a Smart Signature that approves a transaction if and only if:

is “Payment” type transaction;
the receiver is a specific “ADDR”;
fees are less or equal to “1000 microALGO”;
first argument is equal to “bianconiglio”;
amount is  equal to “42 ALGO”;
or amount is equal to “77 ALGO”;

Where do we start?


Smart Signature as “Transaction Observer”
74
Smart Signatures can be defined as a “transactions’ observers”: programs that meticulously check all fields in the transaction (or in a group of transactions) that intend to “approve” or “reject” based on TEAL logic.

To translate those 6 semantically defined example’s conditions into TEAL we need to check which transaction fields are going to be controlled by Smart Signature’s logic.



Let's start with the translation...


Translating conditions into TEAL…
75
is “Payment” type transaction;
txn TypeEnum
int 1
==
1


76
the receiver is a specific “ADDR”;
txn Receiver
addr AOC7...
==
2
Translating conditions into TEAL…


77
fees are less or equal to “1000 microALGO”;
txn Fee
int 1000
<=
3
Translating conditions into TEAL…


78
first argument is equal to “bianconiglio”;
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
4
Translating conditions into TEAL…


79
amount is  equal to “42 ALGO”;
txn Amount
int 42000000
==
5
Translating conditions into TEAL…


80
amount is  equal to “77 ALGO”;
txn Amount
int 77000000
==
6
Translating conditions into TEAL…


81
Logic connectors…
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
[...]
[...]
STACK
[...]
[...]
[...]
1
2
3
4
5
6


82
Logic connectors…
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
[...]
[...]
STACK
[...]
[...]
[...]
1
2
3
4
5
6
This is probably the most complex phase in TEAL programming, because you need to keep in mind the state of the stack.

This phase is drastically simplified with the use of PyTEAL, Python binding for TEAL, which automatically performs this concatenation, saving us the effort of thinking about the state of the stack.


83
Execution…
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
[...]
[...]
[...]
[...]


117
Conclusion…
1
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
STACK
[...]
[...]
[...]
[...]
True


118
PyTEALWriting Smart Contracts with Python

What’s PyTEAL?
119
PyTEAL is a Python language binding for Algorand Virtual Machine.
PyTEAL allows Smart Contracts and Smart Signatures to be written in Python and then compiled to TEAL.
Credits to Jason Paulos for the PyTEAL presentation


120
It’s easier with PyTEAL!
TEAL Source Code
txn Receiver
addr AOC7...
==
txn Amount
int 1000
<=
&&
COMPILE...
AVM bytecode
PyTEAL Source Code
And(
Txn.Receiver == Addr(AOC7...),
    	Txn.Amount <= Int(1000),
)

TEAL Source Code
txn Receiver
addr AOC7...
==
txn Amount
int 1000
<=
&&
COMPILE...
COMPILE...
AVM bytecode


121
Smart Signature written in PyTEAL


PyTEAL Basics - Intro
122
PyTEAL expressions represent an abstract syntax tree (AST)
You’re writing Python code that produces TEAL code.
from pyteal import *

program = ...
teal_source = compileTeal(program, mode=Mode.Application, version=5)


PyTEAL Basics - Types (1/2)
123
Two basic types:
uint64
byte strings
i = Int(5)
x = Bytes("content")
y = Bytes(b"\x01\x02\x03")
z = Bytes("base16", "05")


PyTEAL Basics - Types (2/2)
124
Conversion between types
Itob - integer to bytes (8-byte big endian)
Btoi - bytes to integer
Itob(i) # produces the byte string 0x0000000000000005
Btoi(z) # produces the integer 5


PyTEAL Basics - Math operators
125
Python math operators
i = Int(10)
j = i * Int(2) + Int(1)
k = And(Int(1), Or(Int(1), Int(0)))


PyTEAL Basics - Byte string manipulation
126
Byte string manipulation
x = Bytes("content")
y = Concat(Bytes("example "), x) # "example content"
z = Substring(y, Int(2), Len(y)) # "ample content"


PyTEAL Basics - Crypto utilities
127
Built-in crypto utilities
h_sha256 = Sha256(z)
h_sha512_256 = Sha512_256(z)
h_keccak = Keccak256(z)


PyTEAL Basics - Fields (1/3)
128
Fields from the current transaction
Txn.sender()
Txn.accounts.length()
Txn.application_args.length()
Txn.accounts[1]
Txn.application_args[0]
Txn.group_index()


PyTEAL Basics - Fields (2/3)
129
Fields from transactions in the current atomic group
Gtxn[0].sender()
Gtxn[Txn.group_index() - Int(1)].sender()
Gtxn[Txn.group_index() - Int(1)].accounts[2]


PyTEAL Basics - Fields (3/3)
130
Fields from execution context
Global.group_size()
Global.round() # current round number
Global.latest_timestamp() # UNIX timestamp of last round


PyTEAL Basics - Logs
131
Log publicly viewable messages to the chain
	Log(Bytes("message"))


PyTEAL Basics - State (1/2)
132
Global - one instance per application
App.globalPut(Bytes("status"), Bytes("active")) # write to global key "status"

status = App.globalGet(Bytes("status")) # read global key "status"

App.globalDel(Bytes("status")) # delete global key "status"


PyTEAL Basics - State (2/2)
133
Local - one instance per opted-in account per application
App.localPut(Txn.sender(), Bytes("level"), Int(1)) # write to sender's local key "level"
App.localPut(Txn.accounts[1], Bytes("level"), Int(2))  # write to other account's local key "level"

sender_level = App.localGet(Txn.sender(), Bytes("level"))  # read from sender's local key "level"

App.localDel(Txn.sender(), Bytes("level"))  # delete sender's local key "level"


PyTEAL Basics - Control Flow (1/5)
134
Approve the transaction and immediately exit
Approve()
Reject the transaction and immediately exit
Reject()


PyTEAL Basics - Control Flow (2/5)
135
Multiple expressions can be joined into a sequence
program = Seq(
   App.globalPut(Bytes("count"), App.globalGet(Bytes("count")) + Int(1)),
   Approve()
)


PyTEAL Basics - Control Flow (3/5)
136
Basic conditions can be expressed with If, Then, Else, ElseIf
program = Seq(
   If(App.globalGet(Bytes("count")) == Int(100))
   .Then(
       App.globalPut(Bytes("100th caller"), Txn.sender())
   )
   .Else(
       App.globalPut(Bytes("not 100th caller"), Txn.sender())
   ),
   App.globalPut(Bytes("count"), App.globalGet(Bytes("count")) + Int(1)),
   Approve(),
)


PyTEAL Basics - Control Flow (4/5)
137
Larger conditions can be expressed with Cond
program = Cond(
   [Txn.application_id() == Int(0), on_create],
   [Txn.on_completion() == OnComplete.UpdateApplication, on_update],
   [Txn.on_completion() == OnComplete.DeleteApplication, on_delete],
   [Txn.on_completion() == OnComplete.OptIn, on_opt_in],
   [Txn.on_completion() == OnComplete.CloseOut, on_close_out],
   [Txn.on_completion() == OnComplete.NoOp, on_noop],
   # error if no conditions are met
)


PyTEAL Basics - Control Flow (5/5)
138
Loops can be expressed with For and While
i = ScratchVar(TealType.uint64)

on_create = Seq(
   For(i.store(Int(0)), i.load() < Int(16), i.store(i.load() + Int(1)))
   .Do(
       App.globalPut(Concat(Bytes("index"), Itob(i.load())), Int(1))
   ),
   Approve(),
)


PyTEAL Basics - Subroutines (1/2)
139
Sections of code can be put into subroutines (Python decorators)
@Subroutine(TealType.uint64)
def isEven(i):
   return i % Int(2) == Int(0)

App.globalPut(Bytes("value_is_even"), isEven(Int(10)))


PyTEAL Basics - Subroutines (2/2)
140
Recursion is allowed
@Subroutine(TealType.uint64)
def recursiveIsEven(i):
   return (
       If(i == Int(0))
       .Then(Int(1))
       .ElseIf(i == Int(1))
       .Then(Int(0))
       .Else(recursiveIsEven(i - Int(2)))
   )


PyTEAL Basics - Inner Transactions (1/3)
141
Every application has control of an account
Global.current_application_address()


PyTEAL Basics - Inner Transactions (2/3)
142
Applications can send transactions from this account
Seq(
   InnerTxnBuilder.Begin(),
   InnerTxnBuilder.SetFields(
       {
           TxnField.type_enum: TxnType.Payment,
           TxnField.receiver: Txn.sender(),
           TxnField.amount: Int(1_000_000),
       }
   ),
   InnerTxnBuilder.Submit() # send 1 Algo from the app account to the transaction sender
)


PyTEAL Basics - Inner Transactions (3/3)
143
appAddr = Global.current_application_address()
Seq(
   InnerTxnBuilder.Begin(),
   InnerTxnBuilder.SetFields(
       {
           TxnField.type_enum: TxnType.AssetConfig,
           TxnField.config_asset_name: Bytes("PyTEAL Coin"),
           TxnField.config_asset_unit_name: Bytes("PyTEAL"),
           TxnField.config_asset_url: Bytes("https://pyteal.readthedocs.io/"),
           TxnField.config_asset_decimals: Int(6),
           TxnField.config_asset_total: Int(800_000_000),
           TxnField.config_asset_manager: appAddr,
       }
   ),
   InnerTxnBuilder.Submit(), # create a PyTEAL Coin asset
   App.globalPut(Bytes("PyTealCoinId"), InnerTxn.created_asset_id()) # remember the asset ID
)


A pythonic Algorand stack
144
Algorand Python SDK
PyTEAL
PyTest for Smart Contracts unit-tests and e2e-tests
TEAL Debugger
Algorand Sandbox Docker in dev mode
PyCharm IDE & AlgoDEA plug-in


145
DAPP EXAMPLE & USE CASESExample: zero coupon bond

Zero coupon bond
146
Bondholder purchase a bond (only if KYC has been passed)
Bond application checks for bond’s maturity
Bond Issuer re-pays the Bondholder at given rate


BONDHOLDER
ACCOUNT
BOND ESCROW
CONTRACT ACCOUNT
Zero coupon bond
147
Bondholder purchase a bond (only if KYC has been passed)
BOND
APPLICATION
ATOMIC TRANSACTION

BOND
APPLICATION CALL
CBDC TRANSFER TRANSACTION
BOND TRANSFER TRANSACTION
CBDC
BOND
KYC
APPLICATION
LOCAL STATE

KYC:    PASSED


reads


BONDHOLDER
ACCOUNT
Zero coupon bond
148
Bond application checks for bond’s maturity
BOND ESCROW
CONTRACT ACCOUNT
LOCAL STATE

KYC:    PASSED

BOND MATURE:   NO
BOND
reads
CBDC
BOND
APPLICATION


Zero coupon bond
149
Bond Issuer re-pays the Bondholder at given rate
ATOMIC TRANSACTION

BOND ESCROW
CONTRACT ACCOUNT
BONDHOLDER
ACCOUNT
BOND APPLICATION CALL
BOND TRANSFER TRANSACTION
CBDC TRANSFER TRANSACTION
BOND
APPLICATION
BOND ISSUER
ACCOUNT
CBDC
GLOBAL STATE

INTEREST RATE:    1%
LOCAL STATE

KYC:    PASSED

BOND MATURE:   YES
BOND


Q&A
